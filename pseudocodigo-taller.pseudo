Ciudad struct < 
ganancia : N,
pérdida : N,
balance: Z //puede tener deficit
>

InfoTraslado struct <
id: N, 
origen: N, 
destino: N, 
gananciaNeta: N, 
timestamp: N
>

Módulo BestEffort 
implementa … {
var mayorSuperavit : Heap <Arr<Ciudad>, Balance>, // params = arr, comparable
var mayorGanancia : <ArrayList<N>>,  
var mayorPerdida  : <ArrayList<N>>, // preguntar en clase sobre tipo de datos
var ciudades : <Array<Ciudad>>,
var trasladosMasAntiguos : Heap <ArrayList<Traslado>, Antiguedad>,
var trasladosMasRedituables : Heap <ArrayList<Traslado>, gananciaNeta>,
var gananciaTotal : (N,N) // (suma total, cantidad de traslados)


proc nuevoSistema (in cantCiudades: N, in traslados: seq<InfoTraslado>): BestEffort //O(|cantCiudades| + |traslados|)
	res := new BestEffort;
    res.ciudades = newArray<Ciudad>[cantCiudades];
	i := 0;
    while (i < cantCiudades ) { //O(|cantCiudades|)
        nuevaCiudad = new Ciudad;
        nuevaCiudad.ganancia = 0;
        nuevaCiudad.perdida = 0;
        res.ciudades[i] = nuevaCiudad;
        i ++ ;
    }

    res.mayorGanancia = new ArrayList[cantCiudades]; // nuevo arr tamaño 1
    res.mayorGanancia = res.ciudades;
    res.mayorPerdida = new ArrayList[cantCiudades];
    res.mayorPerdida = res.ciudades;
    res.gananciaTotal = (0,0);

    j := 0;
    while (j < traslados.length()) { //O(|traslados|)
        res.gananciaTotal[0] = res.gananciaTotal[0] + traslados[j].ganancia;
        res.gananciaTotal[1] += 1;
        
        res.ciudades[traslados[j].origen].ganancia += traslados[j].gananciaNeta ;
        res.ciudades[traslados[j].destino].perdida += traslados[j].gananciaNeta ;
        
        res.ciudades[traslados[j].origen].balance += traslados[j].gananciaNeta;
        res.ciudades[traslados[j].destino].balance -= traslados[j].gananciaNeta ;
    
        if (res.mayorGanancia[0] < res.ciudades[traslados[j].origen].ganancia) {
            res.mayorGanancia = [res.ciudades[traslados[j].origen].ganancia] 
        }
        else if (res.mayorGanancia[0] == res.ciudades[traslados[j].origen].ganancia) {
            res.mayorGanancia ++ [res.ciudades[traslados[j].origen].ganancia]
        }

        if (res.mayorPerdida[0] < res.ciudades[traslados[j].origen].perdida) {//devuelve la parte entera de la ganancia promedio por t
            res.mayorPerdida = [res.ciudades[traslados[j].origen].perdida] 
        }
        else if (res.mayorPerdida[0] == res.ciudades[traslados[j].origen].perdida) {
            res.mayorPerdida ++ [res.ciudades[traslados[j].origen].perdida]
        }

        j++;
    }
    
    // creo heaps. primer param el arreglo que recibe y el segundo el comparable
    res.mayorSuperavit = new Heap(res.ciudades, balance); //O(|ciudades|)


    //preguntar si creamos una clase maxHeap y otra minHeap o si Heap recibe un parametro

    res.trasladosMasAntiguos = new Heap(arrTraslados, timestamp, min); //O(|traslados|)
    res.trasladosMasRedituables = new Heap(arrTraslados, ganancia, max); //O(|traslados|)

    end
    //creo que no usaremos Comparable, porque siempre tratamos con int (?)
    class Heap<T extends Comparable<T>> {
        private ArrayList<T> maxHeap;
        //clave:id, valor:  
        private dict<Integer, Integer> positionMap;

        public Heap(ArrayList arr, Comparable comparable){
            this.maxHeap = floydInsert(arr, comparable);
        }

        private void floydInsert(ArrayList arr, Comparable comparable){
            for(int i = arr.length/2 -1; i >= 0; i--){
                heapify(i, arr, comparable);
            }
            this.maxHeap = arr;
        }

        private void heapify(int i, ArrayList arr, Comparable comparable){
            int largest = i;
            int left = 2i + 1;
            int right = 2i + 2;

            if (left < arr.length && arr[left].comparable > arr[largest].comparable){
                largest = left
            }
            if (right < arr.length && arr[right].comparable > arr[largest].comparable){
                largest = right
            }
            if (largest != i){
                swap(i, largest)
                heapify(largest)
            }
        }
        private void swap(int i, int j, arr) {
            //revisar para no hacer aliasing
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            positionMap.add(arr[i].id, arr[i]);
            positionMap.add(arr[j].id, arr[j]);
        }
    }
