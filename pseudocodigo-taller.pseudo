Ciudad struct < 
ganancia : N,
pérdida : N,
balance: Z //puede tener deficit
>

InfoTraslado struct <
id: N, 
origen: N, 
destino: N, 
gananciaNeta: N, 
timestamp: N
>

Módulo BestEffort 
implementa … {
var mayorSuperavit : Heap <Arr<Ciudad>, Balance>, // params = arr, comparable
var mayorGanancia : <ArrayList<N>> ,  
var mayorPerdida  : <ArrayList<N>>, 
var gananciaPromedio : Z,
var ciudades : <Secuencia<Ciudad>>,
var trasladosMasAntiguos : Heap <Arr<Traslado>, Antiguedad>,
var trasladosMasRedituables : Heap <Arr<Traslado>, gananciaNeta>,
var gananciaPromedio : dict(id traslado,(N,N)) //clave el id del traslado, tupla :cantidad de sumas actual, promedio actual. Ej 9+8+3 son 3 sumas. promedio actual = 20/3


proc nuevoSistema (in cantCiudades: N, in traslados: seq<InfoTraslado>): BestEffort //O(|cantCiudades| + |traslados|)
	res := new BestEffort;
	i := 0;
    while (i < cantCiudades ) { //O(|cantCiudades|)
        nuevaCiudad = new Ciudad;
        nuevaCiudad.ganancia = 0;
        nuevaCiudad.perdida = 0;
        res.ciudades[i] = nuevaCiudad;
        i ++ ;
    }

    res.mayorGanancia = new ArrayList[1]; // nuevo arr tamaño 1
    res.mayorGanancia[0] = res.ciudades[0];
    res.mayorPerdida = new ArrayList[1];
    res.mayorPerdida[0] = res.ciudades[0];

    //creo un arreglo de traslados que voy a usar de parametro para crear los heaps. Si yo fuese reordenando un heap dentro del while tendria O(n log n)
    //hay que revisar si esto es realmente lo mejor
    arrTraslados = new ArrayList[traslados.length] <Traslado>

    j := 0;
    while (j < traslados.length()) { //O(|traslados|)
        res.ciudades[traslados[j].origen].ganancia += traslados[j].gananciaNeta ;
        res.ciudades[traslados[j].destino].perdida += traslados[j].gananciaNeta ;
        
        res.ciudades[traslados[j].origen].balance += traslados[j].gananciaNeta;
        res.ciudades[traslados[j].destino].balance -= traslados[j].gananciaNeta ;
    
        if (res.mayorGanancia[0] < res.ciudades[traslados[j].origen].ganancia) {
            res.mayorGanancia = res.ciudades[traslados[j].origen].ganancia 
        }
        else if (res.mayorGanancia[0] == res.ciudades[traslados[j].origen].ganancia) {
            res.mayorGanancia ++ [res.ciudades[traslados[j].origen].ganancia]
        }

        if (res.mayorPerdida[0] < res.ciudades[traslados[j].origen].perdida) {
            res.mayorPerdida = res.ciudades[traslados[j].origen].perdida 
        }
        else if (res.mayorPerdida[0] == res.ciudades[traslados[j].origen].perdida) {
            res.mayorPerdida ++ [res.ciudades[traslados[j].origen].perdida]
        }

        arr.Traslados[j] = traslados[j]
        //setKey?
        //(promedio actual * cantidad de sumas + gananciaNeta) / (cantidadSumas + 1) a ver si te sale mas facil, salu2
        res.gananciaPromedio(traslados[j].id[1]) = (res.gananciaPromedio(traslados[j].id[1]) * res.gananciaPromedio(traslados[j].id[0]) + traslados[j].gananciaNeta) / (traslados[j].id[0] + 1)
        res.gananciaPromedio(traslados[j].id[0]) = res.gananciaPromedio(traslados[j].id[0]) + 1
    }
    
    // creo heaps. primer param el arreglo que recibe y el segundo el comparable
    res.mayorSuperavit = new Heap(res.ciudades, balance); //O(|ciudades|)
    res.trasladosMasAntiguos = new Heap(arrTraslados, timestamp); //O(|traslados|)

    end
    //creo que no usaremos Comparable, porque siempre tratamos con int (?)
    class Heap<T extends Comparable<T>> {
        private ArrayList<T> maxHeap;
        //clave:id, valor:posicion. No implementado, hasta aca llego por ahora
        private dict<Integer, Integer> positionMap;

        public Heap(ArrayList arr, Comparable comparable){
            this.maxHeap = floydInsert(arr, comparable);
        }

        private void floydInsert(ArrayList arr, Comparable comparable){
            for(int i = arr.length/2 -1; i >= 0; i--){
                heapify(i, arr, comparable);
            }
            this.maxHeap = arr;
        }

        private void heapify(int i, ArrayList arr){
            int largest = i;
            int left = 2i + 1;
            int right = 2i + 2;

            if (left < arr.length && arr[left].comparable > arr[largest].comparable){
                largest = left
            }
            if (right < arr.length && arr[right].comparable > arr[largest].comparable){
                largest = right
            }
            if (largest != i){
                swap(i, largest)
                heapify(largest)
            }
        }
        private void swap(int i, int j, arr) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
